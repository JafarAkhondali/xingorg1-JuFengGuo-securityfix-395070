vue学习笔记
## 1. 什么是vue？

**渐进式框架**：  
如果项目很简单，就可以只用vue的一小部分功能来实现。  
如果项目很复杂，需要多个页面，可以引入vue-router实现路由跳转，  
              需要多个组件，就可以用vuex进行状态管理  
总之，无论怎么样，都能使用vue  
![渐进式框架](./1-introduce/vue.png '渐进式框架')  

## 2. MVVM框架
M: Model（数据）  
V: View（视图）  
VM: ViewModel（链接视图和数据）  

视图通过dom事件改变数据，数据通过数据绑定的方式来影响视图。 ViewModel是链接二者，使之互相练习、互相影响。

## 3. vue与jquery相比较，优势是啥？
* 视图与数据分离 （不用操作dom）  
* 性能更好（只操作虚拟dom减少性能消耗）  
* 维护成本低（只需要管理数据即可）  

## 4. vue性能为什么好 —— 什么会影响web应用的性能？
操作dom是会影响性能的，因为操作dom是十分昂贵的。宁可处理一万次js，也不操作一次dom。  

### 4-1. 想想哪些方法可以修改自己web应用的代码，以优化项目性能？
a. 减少DOM操作的次数（DOM的获取与修改）  
b. 减少网络请求  
c. 压缩、合并静态资源文件（css、js、img等）  
d. 小图片文件base64化处理  
e. js少用全局变量  
f. ...

### 4-2. dom是什么？JS和 DOM是什么关系？
DOM就是Document Object Model,文档对象模型，里边是接口（方法函数，我们通过调用并传指定参数来使用）  
DOM是一个独立于语言的，用于操作XML和HTML文档的程序接口(其实就是API)。在浏览器中主要用于与HTML文档打交道，并且使用DOM API用来访问文档中的数据。  
DOM是个与语言无关的API，它在浏览器中的接口却是用JavaScript来实现的。客户端脚本编程大多数都是在和底层文档打交道，DOM就成为现在JS编码中的重要部分。  


#### 4-2-1. JS和 DOM是两种东西：
JS(更确切来说是ES)通多DOM接口来获取文档中的元素。(python也可以操作DOM)  
浏览器中通常会把DOM和javascript独立实现。**二者相互独立**，就像两座孤岛。**JS与DOM每次连接都需要消耗性能**  
（ES每次操作DOM时，ES和DOM之间就像两个桥之间过车辆，每次链接都需要搭建一个桥梁，搭桥还是小事，  
但是JS请求DOM的车辆过桥时，会经过一个收费站，每次都会被收费。JS引擎会消耗浏览器的性能缴费。所以说每次链接都需要消耗性能。  
也正因此，有了没操作一次DOM，就多干点事的理念，尽可能最少次数的操作DOM，最多的事情处理。VUE就实现了这种理念。）  

#### 4-2-2. DOM的位置和JavaScript的位置（相互独立）  
浏览器 | JS位置 | DOM位置
:-: | - | -
IE | JavaScript的实现名为JScript，位于jscript.dll文件中 | DOM的实现则存在另一个库中，名为mshtml.dll（内部称为trident）
safari | JavaScript部分是由独立的SquirelFish引擎来实现。 | DOM和渲染是使用webkit中的webcore实现
google chrome | JavaScript引擎是他们自己研发的，名为V8。 | 使用webkit中的webCore库来渲染页面
firefox | JavaScript引擎名为TraceMonkey | 渲染引擎Gecko




#### 4-2-3. JS访问DOM元素是有代价的。因为每次链接都需要消耗性能：  
正因为二者相互独立，所以每次链接、每次访问DOM会消耗性能  

#### 4-2-4. JS修改DOM元素的代价，则更为昂贵，会导致浏览器渲染引擎的重排和重绘：  
每次操作DOM之前，就会先访问DOM，所以也会消耗性能  
在此基础上，因为修改DOM会导致浏览器重新计算页面的几何变化、引发浏览器模板引擎的重排(回流 - 回滚流程)和重绘，更加消耗性能  

### 4-3. 浏览器渲染引擎的工作原理、工作流程是什么？

#### 4-3-1. 浏览器下载完页面中的所有组件：比如HTML、JavaScript、CSS、图片后，会发生如下的6步过程：  	
1. 解析HTML，构建DOM树（DOM Tree）  
2. 解析CSS，生成CSS规则树（CSSOM Tree）  
3. 合并DOM树和CSS规则树，生成渲染树render树（render Tree）  
4. 布局render树，根据生成的render树来对各元素尺寸、位置进行计算，得到每个节点的几何信息。（根据视口的大小来计算元素的位置和大小）（重排会走这一步）    
5. 绘制render树，绘制页面像素信息（根据render树上每个节点的几何信息，得到每个节点的像素数）（重绘会走这一步）  
6. 浏览器会将各层节点的像素信息发送给GPU，GPU将各层合成、绘制展示到页面上  


#### 4-3-2. 生成渲染树（render Tree）的，浏览器渲染引擎时候做了什么事情？
先看一张图：  
![浏览器如何生成渲染树](./1-introduce/renderTree.png '浏览器如何生成渲染树')  

再文字说明如下流程：  
1. 从DOM Tree的根节点开始遍历每一个可见节点（除meta、link、script等这些标签；除display:none;的元素）
2. 对于每个可见节点，在CSSOM中找到对应规则并将样式规则应用到对应节点上。  
3. 根据每一个可见节点，以及其对应的样式，组合生成渲染树。


**不可见节点：**  
不会渲染输出的节点（不会显示在屏幕上的节点）  
* meta、link、script等标签;  
* 通过css进行隐藏的节点，即display:none；（opacity对人类不可见，计算机还能看见，所以还会渲染。）（那visibility为隐藏的元素会不会被渲染呢？做个试验，一个div设置visibility不可见，左浮动，周围全是文字，看文字环绕是否让出一块空白区域。最后试验证明确实绕出了一段空白的位置，说明visibility和opacity设置的不可见只是对人类肉眼不可见，计算机还是会在生成render Tree的时候计算位置信息并把他绘制出来。）  

试验结果如下图：  
![visibility为隐藏的元素会不会被渲染](./1-introduce/visibility.png 'visibility为隐藏的元素会不会被渲染')  


### 4-4. 什么是浏览器渲染引擎的重排和重绘？
**重排：**  
当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和**位置**也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为重排  

换句话说，改变了页面中某元素的位置、尺寸大小，进而也就改变了他的占地面积。那这个元素修改了战地面积后，其后紧邻的元素就得挪动位置。给她让地儿（或者向前赶赶）。紧邻的元素挪动了，那紧邻元素后边的元素也会连锁效应式的修改。这就好比一排人排队。前边的人突然变胖了、变瘦了、向前挪了、向后挤了、都会导致后边的人也跟随着改变，由此导致一连串的人都挪动位置。这时浏览器就要重新排版各个受到影响的元素的位置。反应在渲染引擎的工作流程中也就是浏览器需要重新计算元素位置信息并布局render树。这就是重排。  

**重绘：**  
完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。  
因为重排在重绘的上一步，所以重排发生后自然会再走重绘。这个很好理解。  



### 4-5. 什么时候会引发重排？
当页面布局和几何属性改变时就需要重排：  
（核心就是：只要某个属性能导致位置信息发生改变，就会触发重排 ）  
1. 添加或删除可见的DOM元素。(一堆人排队，添加即中间插入了一个人/删除即中间一个人走了，势必会影响后边排队的人的位置信息也发生改变)  
2. 元素位置改变（重排就是因为位置信息改变了）  
3. 元素尺寸改变( 外边距、内边距、边框厚度、宽度、高度等)  
4. 内容改变，例：文本改变或图片被另一个不同尺寸的图片替代、字体大小改变、（文字加粗？）导致DOM元素位置、面积改变。【计算会消耗CPU的能力】  
5. 页面渲染器初始化（这是重走流程吧）  
6. 浏览器窗口尺寸改变（位置信息会被迫调整，发生重排。见下图的gif图，一个页面中div元素的位置不受视口调整而修改，也会引发重排）【消耗GPU的计算能力】  

试验：resize视口，一个页面中div元素的位置不受视口调整而修改，也会引发重排    
![resize视口会引发重排 ](./1-introduce/resize-reflow.gif 'resize视口会引发重排')  



### 4-5-1. 打断浏览器的优化步骤  
现代浏览器是相当完善的了，因为多次操作DOM会触发重排重绘、消耗性能，所以除了我们人为的、有意识的去控制操作DOM次数以外，浏览器在设计上进行了优化，也会智能的“节流”操作DOM，队列化修改、批量执行。  

解释来说就是，浏览器会有一个“队列”，用以存放（攒着）需要操作DOM的js程序。每当执行一次js操作dom的代码，这个队列里就先暂存一个程序。等到一段时间后，浏览器再集中、批量的链接一次JS岛和DOM岛（就是让js引擎去链接渲染引擎？），进而触发一次DOM操作。  

但是我们人类感知不到啊，可能会因为误操作打断浏览器的“节流”步骤。迫使浏览器中断当前的“节流”流程，去赶紧、立马进行一次dom操作。让浏览器赶紧执行完他攒在“队列”里的JS操作DOM的程序后返回最新的DOM位置信息给我们，就好像电梯门定时自动关闭，但是你却手动按了关门按钮强迫关门一样。  

这种情况就发生在我们获取DOM信息的时候：  

**打断浏览器优化，强迫触发重排的属性：**   
offsetTop、offsetLeft、offsetWidth、offsetHeight  
scrollTop、scrollLeft、scrollWidth、scrollHeight  
clientTop、clientLeft、clientWidth、clientHeight  
getComputedStyle()  

因为要跟浏览器请求最新的DOM信息，所以浏览器就得赶紧让JS引擎去渲染引擎那里进行一次DOM操作。  


### 4-6. 什么时候会引发重绘？  
1. 重排必然引发重绘，这是肯定的。因为浏览器的工作流程就是排版后渲染。重排会回流（回滚流程）到排版阶段，排版后会重新绘制页面。  
2. 单独触发重绘的情况：   
除元素尺寸、位置发生改变以外的情况，（比如字体颜色、背景色等发生改变）。（我感觉文字加粗也会触发重排，但是我没有证据。如果在一个固定尺寸的div内加粗文字，应该不会影响后边元素的重排，但可能该div内部的其他相邻文字或元素会发生重排。）    

试验gif图：    
![resize视口会引发重排 ](./1-introduce/fontweight-reflow.gif 'resize视口会引发重排')  

（想到一个验证只发生重绘的情况，那就是后边也加点元素，如果重排了，后边的元素在控制台的检测下也会闪绿光。）   


#### 各css属性对重排重绘的影响：https://csstriggers.com/  

### 4-7. 控制台观察一个页面的重排和重绘现象
因为重排必然会引发重绘，所以在浏览器的开发者工具中提供了一个检测重绘的按钮。寻找和打开步骤如下图：    
![控制台开启重绘检测按钮](./1-introduce/repaintSwitch.png '控制台开启重绘检测按钮')

### 4-8. 为什么不提倡重排和重绘？
既然知道了这个dom操作会触发重排、重绘。那又是为什么要尽量避免重排和重绘呢？  
换句话说，重排和重绘的副作用是什么？缺点是什么？  

这就要引入CPU和GPU了。  

**重排会占用CPU**，dom元素位置计算会消耗CPU的算力，所以应该尽量减少CPU的占用，使电脑不卡顿。  
**重绘会占用GPU**，渲染页面时会消耗GPU的算力。  

**GPU的分类：**  
1. 家用GPU   
    适合做贴图、特效、光影等效果。不适合画图形。  
2. 专业GPU  
    适合画图形。不适合做贴图、特效、光影等效果。  
  
DOM操作基本就是画图形的，且浏览器中用的就是**家用GPU，其画图形耗费的性能是专业GPU的几十倍**。所以不提倡频繁用装有家用GPU的浏览器绘制页面。也就是不提倡频繁触发重绘。  
 
### 4-9. 总结： 为什么操作DOM非常昂贵？
1. JS和 DOM是两种东西，每次连接都需要消耗性能  

2. 操作DOM会导致重排和重绘，重排会占用、消耗CPU; 重绘会占用、消耗GPU  




### 4-10. 回答问题4 - vue性能为什么好？
为什么vue的性能会更好？  
因为：vue的核心是**虚拟dom**，使用虚拟dom可以减少dom的操作，从而提升应用的性能。    

## 5. 虚拟dom
虚拟dom：virtual dom （也被称为vdom）  

所谓虚拟dom，即为伪dom，假的dom，他不是一个真实的dom，而是由JS来模拟出来的具有真实dom结构的一个树形结构。  

虚拟DOM是一个库   
vue2.0中借鉴了[snabbdom](https://github.com/snabbdom/snabbdom 'snabdom')


### 5-1. 为什么要用JS来模拟dom结构？又为什么是JS，html不能模拟吗？
1. 在前端的三种语言（html、css、javaScript）中，只有JS是一种编程语言，只有JS能做到判断、循环、递归、能够实现各种逻辑、实现各种算法。  
2. dom的操作是昂贵的，js的运行效率更高，将dom对比放在js层，减少dom操作，效率更高。  

### 5-2. 用js模拟virtual dom ：
```html
<section class="main">
  <header class="header">我是标题</header>
  <div class="cont" id="container">
    <nav class="nav-box" style="float: left;">
      侧边栏
    </nav>
    <article data-articleId="12">
      我是正文
    </article>
  </div>
  <footer>我是尾巴</footer>
</section>
```
```js
// 虚拟DOM - js模拟DOM
var vnode = {
  //tag（字符串）表示标签的名字
  tag: 'section',
  // attrs（对象）用于存放标签上的属性键值对
  attrs: {
    class: 'main',
  },
  // children（数组）表示对当前tag内部每一个子元素的模拟
  children: [
    {
      tag: 'header',
      attrs: {
        class: 'header',
      },
      children: ['我是标题']//标签内文本在attrs的children数组中存放？？？还是老师写错了
    },
    {
      tag: 'div',
      attrs: {
        class: 'cont',
        id: 'container'
      },
      children: [
        {
          tag: 'nav',
          attrs: {
            class: 'nav-box',
            style: 'float: left;'
          },
          children:[' 侧边栏']
        },{
          tag: 'article',
          attrs: {
            "data-articleId": '12'//是因为虚拟dom的原因，这种横线格式的属性名会变成小驼峰？
          },
          children:['我是正文']
        }
      ]
    },
    {
      tag: 'footer',
      children: ['我是尾巴']
    }
  ]
}
```

### 5-3. jq与vue写同样一段逻辑，进行对比谁的dom操作更多。


## 6. vue视图与数据是如何分离的？
todo-list例子看jq和vue分别怎么写。  

视图中进行dom操作，数据里进行逻辑修改。数据驱动视图。  
vm只用关心数据的变化，处理数据就是处理数据，显示视图就是显示视图，分层来做，这样更符合思考的逻辑  


## 7. 为什么vue维护成本低？
1. VUE的代码量更少  
只需要修改数据就能更改视图代码量少（jq中很大一部分是操作dom的）  
2. VUE的逻辑更清晰  
  视图修改和数据操作分离，自然清晰。

